<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>éœ“è™¹è¡—é ­ç±ƒçƒ - Neon Dunk</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Noto+Sans+TC:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #0f172a;
            touch-action: none;
            overflow: hidden;
        }
        canvas {
            /* è§£æ±ºæ‰‹æ©Ÿä¸Šçš„é‹¸é½’å•é¡Œ */
            image-rendering: -webkit-optimize-contrast;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #ff00de, 0 0 30px #ff00de;
        }
        .font-game {
            font-family: 'Black Ops One', cursive;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center bg-slate-900">

    <div id="game-container" class="relative w-full max-w-md h-full max-h-[850px] bg-gray-800 sm:rounded-xl shadow-2xl overflow-hidden border-0 sm:border-4 border-gray-700 ring-1 ring-white/10">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD: åˆ†æ•¸èˆ‡æ™‚é–“ -->
        <div id="hud" class="absolute top-0 w-full p-4 flex justify-between items-start pointer-events-none transition-opacity duration-300 opacity-0">
            <div class="flex flex-col items-start">
                <span class="text-gray-400 text-xs font-bold uppercase tracking-wider">SCORE</span>
                <span id="scoreDisplay" class="text-4xl text-white font-game tracking-widest drop-shadow-md">0</span>
                <div id="comboContainer" class="opacity-0 transition-all duration-300 transform scale-0">
                    <span class="text-yellow-400 font-bold text-sm italic">COMBO x<span id="comboCount">0</span>!</span>
                </div>
            </div>
            <div class="flex flex-col items-end">
                <span class="text-gray-400 text-xs font-bold uppercase tracking-wider">TIME</span>
                <span id="timeDisplay" class="text-4xl text-white font-game tracking-widest drop-shadow-md">60</span>
            </div>
        </div>

        <!-- é–‹å§‹ç•«é¢ -->
        <div id="startScreen" class="absolute inset-0 z-20 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm transition-opacity duration-500">
            <h1 class="text-6xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 font-game mb-2 neon-text text-center leading-tight">NEON<br>DUNK</h1>
            <p class="text-gray-300 mb-8 text-sm tracking-widest">æ¥µè‡´æ‰‹æ„Ÿç±ƒçƒé«”é©—</p>
            
            <div class="glass-panel p-6 rounded-xl mb-8 w-64 text-center">
                <div class="flex justify-center items-center space-x-4 mb-4">
                    <div class="w-12 h-12 rounded-full border-2 border-white/30 flex items-center justify-center animate-bounce">ğŸ‘‡</div>
                    <span class="text-white font-bold">å‘å¾Œæ‹‰</span>
                </div>
                <div class="h-px w-full bg-white/10 mb-4"></div>
                <p class="text-cyan-300 text-xs">ç„æº–æ‹‹ç‰©ç·š Â· æ”¾é–‹æŠ•ç±ƒ<br>é€£é€²è¶Šå¤š Â· åˆ†æ•¸è¶Šé«˜</p>
            </div>

            <button id="btnStart" class="group relative px-8 py-4 bg-cyan-600 hover:bg-cyan-500 rounded-full text-white font-bold text-xl transition-all shadow-[0_0_20px_rgba(8,145,178,0.6)] hover:shadow-[0_0_40px_rgba(8,145,178,0.8)] hover:scale-105 active:scale-95">
                <span class="relative z-10">START GAME</span>
            </button>
        </div>

        <!-- çµç®—ç•«é¢ -->
        <div id="endScreen" class="absolute inset-0 z-20 flex flex-col items-center justify-center bg-black/90 backdrop-blur-md hidden">
            <h2 class="text-4xl text-white font-game mb-2">TIME UP</h2>
            <div class="text-center mb-8">
                <p class="text-gray-400 text-sm uppercase tracking-widest">Total Score</p>
                <p id="finalScore" class="text-7xl text-yellow-400 font-game neon-text">0</p>
            </div>
            <button id="btnRestart" class="px-8 py-3 border-2 border-white text-white rounded-full hover:bg-white hover:text-black transition-all font-bold uppercase tracking-widest">
                Play Again
            </button>
        </div>
    </div>

<script>
/**
 * éŠæˆ²æ ¸å¿ƒé‚è¼¯
 * åŒ…å«ï¼šéŸ³æ•ˆåˆæˆã€ç‰©ç†æ¨¡æ“¬ã€ç²’å­ç³»çµ±ã€æ¸²æŸ“å¾ªç’°
 */

// --- éŸ³æ•ˆæ§åˆ¶å™¨ (ç„¡éœ€å¤–éƒ¨è³‡æº) ---
const AudioSys = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() { this.playTone(150, 'triangle', 0.2, 0.1); },
    playRim() { this.playTone(80, 'square', 0.1, 0.05); }, // æ‰“éµè²
    playScore() { 
        // é›™é‡éŸ³æ•ˆä»£è¡¨é€²çƒ
        this.playTone(600, 'sine', 0.15, 0.1);
        setTimeout(() => this.playTone(900, 'sine', 0.3, 0.05), 50);
    },
    playCombo() {
        // ç«åŠ›å…¨é–‹éŸ³æ•ˆ
        this.playTone(400, 'sawtooth', 0.1, 0.1);
        setTimeout(() => this.playTone(600, 'sawtooth', 0.1, 0.1), 100);
        setTimeout(() => this.playTone(800, 'sawtooth', 0.3, 0.1), 200);
    }
};

// --- éŠæˆ²å¸¸æ•¸ ---
const CONSTANTS = {
    GRAVITY: 0.25, // é‡åŠ›
    AIR_RESISTANCE: 0.99,
    RIM_Y: 220, // ç±ƒæ¡†é«˜åº¦
    RIM_Z: 150, // ç±ƒæ¡†æ·±åº¦
    RIM_RADIUS: 35,
    PERSPECTIVE: 800, // é€è¦–å¼·åº¦
    FLOOR_Y: 700
};

// --- ç•«å¸ƒè¨­å®š ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// --- éŠæˆ²ç‹€æ…‹ ---
let state = {
    score: 0,
    time: 60,
    combo: 0,
    isPlaying: false,
    ball: null,
    hoop: { x: 0, y: CONSTANTS.RIM_Y, z: CONSTANTS.RIM_Z, dir: 1, speed: 2 },
    drag: { active: false, startX: 0, startY: 0, currX: 0, currY: 0 },
    particles: [],
    shake: 0, // ç•«é¢éœ‡å‹•å¼·åº¦
    lastTime: 0
};

// --- ç‰©ä»¶é¡åˆ¥ ---

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * 4 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
        this.vy += 0.2; // é‡åŠ›
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Ball {
    constructor() {
        this.reset();
        this.radius = 22;
        this.rotation = 0;
    }

    reset() {
        this.x = width / 2;
        this.y = height - 150;
        this.z = 0;
        this.vx = 0; this.vy = 0; this.vz = 0;
        this.isFlying = false;
        this.rotation = 0;
        this.scored = false;
        // ç¢ºä¿çƒåœ¨é‡ç½®æ™‚ä¸æœƒæœ‰æ®˜ç•™é€Ÿåº¦
    }

    shoot(vx, vy, vz) {
        this.vx = vx;
        this.vy = vy;
        this.vz = vz;
        this.isFlying = true;
        AudioSys.playShoot();
    }

    update() {
        if (!this.isFlying) return;

        // ç‰©ç†é‹ç®—
        this.vy += CONSTANTS.GRAVITY;
        this.vx *= CONSTANTS.AIR_RESISTANCE;
        this.vz *= CONSTANTS.AIR_RESISTANCE;

        this.x += this.vx;
        this.y += this.vy;
        this.z += this.vz;
        
        this.rotation += this.vx * 0.1;

        // 1. åœ°æ¿ç¢°æ’ (é‡ç½®)
        if (this.y > CONSTANTS.FLOOR_Y) {
            // ç¨å¾®å½ˆä¸€ä¸‹å†æ¶ˆå¤±
            if (Math.abs(this.vy) > 2) {
                this.vy *= -0.5;
                this.y = CONSTANTS.FLOOR_Y;
            } else {
                // çƒåœæ­¢ï¼Œé‡ç½®å›åˆ
                handleMiss();
            }
        }

        // 2. ç±ƒæ¡†ç‰©ç† (ç°¡åŒ–ç‰ˆ AABB/Circle)
        // åªæœ‰ç•¶çƒé”åˆ°ç±ƒæ¡†æ·±åº¦é™„è¿‘æ™‚æ‰æª¢æ¸¬
        if (this.z > state.hoop.z - 20 && this.z < state.hoop.z + 20) {
            // è¨ˆç®—çƒåˆ°ç±ƒæ¡†ä¸­å¿ƒçš„ 2D è·é›¢
            const dx = this.x - state.hoop.x;
            const dy = this.y - state.hoop.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // é€²çƒåˆ¤å®š (çƒå¿…é ˆåœ¨å‘ä¸‹è½)
            if (dist < CONSTANTS.RIM_RADIUS * 0.8 && this.vy > 0 && !this.scored) {
                handleScore(this.x, this.y);
                this.scored = true;
            }
            // æ’æ¡†åˆ¤å®š (Rim Hit)
            else if (dist < CONSTANTS.RIM_RADIUS + this.radius && dist > CONSTANTS.RIM_RADIUS - 10 && !this.scored) {
                // ç°¡å–®çš„åå½ˆç‰©ç†
                this.vx *= -0.6;
                this.vy *= -0.6;
                this.vz *= -0.4;
                AudioSys.playRim();
                addShake(5);
            }
        }

        // 3. ç±ƒæ¿åˆ¤å®š (ç°¡å–®ç‰ˆ)
        if (this.z > state.hoop.z + 10 && this.z < state.hoop.z + 50) {
            if (Math.abs(this.x - state.hoop.x) < 60 && Math.abs(this.y - (state.hoop.y - 60)) < 50) {
                this.vz *= -0.5; // åå½ˆå›ä¾†
                this.vy *= 0.8;
                AudioSys.playRim();
            }
        }
    }

    draw(ctx) {
        // 3D é€è¦–æŠ•å½±
        const scale = CONSTANTS.PERSPECTIVE / (CONSTANTS.PERSPECTIVE + this.z);
        const screenX = width/2 + (this.x - width/2) * scale;
        const screenY = height/2 + (this.y - height/2) * scale; // ç°¡åŒ–è¦–è§’
        const r = this.radius * scale;

        if (this.z < 0) return; // è¦–è§’å¾Œä¸ç•«

        // é™°å½± (æ ¹æ“šé«˜åº¦)
        if (this.y < CONSTANTS.FLOOR_Y) {
            const shadowScale = scale * (1 - (CONSTANTS.FLOOR_Y - this.y)/1000);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(screenX, height/2 + (CONSTANTS.FLOOR_Y - height/2)*scale, r*shadowScale, r*shadowScale*0.3, 0, 0, Math.PI*2);
            ctx.fill();
        }

        // çƒé«”
        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.rotate(this.rotation);

        // çƒé«”æ¼¸å±¤
        const grad = ctx.createRadialGradient(-r*0.2, -r*0.2, r*0.2, 0, 0, r);
        grad.addColorStop(0, '#fb923c'); // Orange-400
        grad.addColorStop(1, '#c2410c'); // Orange-700
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI*2);
        ctx.fill();

        // çƒç´‹ (ç·šæ¢)
        ctx.strokeStyle = '#7c2d12';
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.moveTo(-r, 0); ctx.lineTo(r, 0); // æ°´å¹³ç·š
        ctx.moveTo(0, -r); ctx.lineTo(0, r); // å‚ç›´ç·š
        ctx.stroke();
        
        // å…‰æ¾¤
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath();
        ctx.arc(-r*0.3, -r*0.3, r*0.2, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

// --- éŠæˆ²é‚è¼¯å‡½æ•¸ ---

function init() {
    resize();
    window.addEventListener('resize', resize);
    
    // äº‹ä»¶ç¶å®š
    const el = document.getElementById('game-container');
    el.addEventListener('mousedown', onInputStart);
    el.addEventListener('mousemove', onInputMove);
    window.addEventListener('mouseup', onInputEnd);
    
    el.addEventListener('touchstart', onInputStart, {passive: false});
    el.addEventListener('touchmove', onInputMove, {passive: false});
    window.addEventListener('touchend', onInputEnd);

    document.getElementById('btnStart').onclick = startGame;
    document.getElementById('btnRestart').onclick = startGame;
    
    state.ball = new Ball();
    
    // å•Ÿå‹•æ¸²æŸ“å¾ªç’°
    requestAnimationFrame(loop);
}

function resize() {
    const container = document.getElementById('game-container');
    width = container.clientWidth;
    height = container.clientHeight;
    canvas.width = width;
    canvas.height = height;
    if(state.ball && !state.ball.isFlying) state.ball.reset();
}

function startGame() {
    AudioSys.init();
    state.score = 0;
    state.time = 60;
    state.combo = 0;
    state.isPlaying = true;
    state.ball.reset();
    state.particles = [];
    
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('endScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('opacity-0');
    updateHUD();

    // è¨ˆæ™‚å™¨
    clearInterval(state.timerIdx);
    state.timerIdx = setInterval(() => {
        state.time--;
        updateHUD();
        if(state.time <= 0) endGame();
    }, 1000);
}

function endGame() {
    state.isPlaying = false;
    clearInterval(state.timerIdx);
    document.getElementById('finalScore').textContent = state.score;
    document.getElementById('endScreen').classList.remove('hidden');
    document.getElementById('hud').classList.add('opacity-0');
}

function handleScore(x, y) {
    // é€£æ“Šç³»çµ±
    state.combo++;
    let points = 2;
    if (state.combo > 1) points += state.combo; // é€£æ“ŠåŠ åˆ†
    
    state.score += points;
    state.time += 1; // é€²çƒçå‹µæ™‚é–“
    
    // ç‰¹æ•ˆ
    if(state.combo >= 3) AudioSys.playCombo();
    else AudioSys.playScore();
    
    addShake(10);
    spawnParticles(x, y, 20, state.combo >= 3 ? '#ef4444' : '#facc15'); // ç«ç„°ç´…æˆ–é‡‘é»ƒ
    
    updateHUD();
    
    // è¦–è¦ºæ–‡å­—
    spawnFloatText(state.combo > 1 ? `COMBO x${state.combo}` : "+2", x, y - 50);
}

function handleMiss() {
    state.combo = 0;
    state.ball.reset();
    updateHUD();
}

function updateHUD() {
    document.getElementById('scoreDisplay').textContent = state.score;
    document.getElementById('timeDisplay').textContent = state.time;
    
    const comboEl = document.getElementById('comboContainer');
    const comboCount = document.getElementById('comboCount');
    if(state.combo > 1) {
        comboEl.classList.remove('scale-0', 'opacity-0');
        comboEl.classList.add('scale-110', 'opacity-100');
        comboCount.textContent = state.combo;
    } else {
        comboEl.classList.remove('scale-110', 'opacity-100');
        comboEl.classList.add('scale-0', 'opacity-0');
    }
}

function spawnParticles(x, y, count, color) {
    const scale = CONSTANTS.PERSPECTIVE / (CONSTANTS.PERSPECTIVE + state.hoop.z);
    const screenX = width/2 + (x - width/2) * scale;
    const screenY = height/2 + (y - height/2) * scale;
    
    for(let i=0; i<count; i++) {
        state.particles.push(new Particle(screenX, screenY, color));
    }
}

let floatTexts = [];
function spawnFloatText(text, x, y) {
     const scale = CONSTANTS.PERSPECTIVE / (CONSTANTS.PERSPECTIVE + state.hoop.z);
     const screenX = width/2 + (x - width/2) * scale;
     const screenY = height/2 + (y - height/2) * scale;
     floatTexts.push({text, x: screenX, y: screenY, life: 1.0});
}

function addShake(amount) {
    state.shake = amount;
}

// --- è¼¸å…¥è™•ç† (æ‹–æ›³/å½ˆå¼“) ---

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const t = e.touches ? e.touches[0] : e;
    return { x: t.clientX - rect.left, y: t.clientY - rect.top };
}

function onInputStart(e) {
    if(!state.isPlaying || state.ball.isFlying) return;
    e.preventDefault();
    const p = getPos(e);
    
    // åˆ¤æ–·æ˜¯å¦é»æ“Šåˆ°çƒé™„è¿‘
    const dx = p.x - state.ball.x;
    const dy = p.y - state.ball.y;
    if (Math.sqrt(dx*dx + dy*dy) < 80) {
        state.drag.active = true;
        state.drag.startX = p.x;
        state.drag.startY = p.y;
        state.drag.currX = p.x;
        state.drag.currY = p.y;
    }
}

function onInputMove(e) {
    if(!state.drag.active) return;
    e.preventDefault();
    const p = getPos(e);
    state.drag.currX = p.x;
    state.drag.currY = p.y;
}

function onInputEnd(e) {
    if(!state.drag.active) return;
    
    // è¨ˆç®—ç™¼å°„å‘é‡ (åå‘)
    // é™åˆ¶æœ€å¤§æ‹‰åŠ›
    let dx = state.drag.startX - state.drag.currX;
    let dy = state.drag.startY - state.drag.currY;
    
    // å¦‚æœæ‹‰çš„è·é›¢å¤ªçŸ­ï¼Œè¦–ç‚ºå–æ¶ˆ
    if (Math.sqrt(dx*dx + dy*dy) < 20) {
        state.drag.active = false;
        return;
    }

    const power = 0.18;
    const vz = Math.min(Math.max(dy * 0.5, 10), 50); // æ·±åº¦åŠ›é‡
    const vy = -Math.min(Math.max(dy * 0.4, 15), 40); // å‘ä¸ŠåŠ›é‡
    const vx = dx * 0.2; // å·¦å³åŠ›é‡

    state.ball.shoot(vx, vy, vz);
    state.drag.active = false;
}

// --- ä¸»è¦ç¹ªåœ–å¾ªç’° ---

function loop(timestamp) {
    // æ¸…é™¤ç•«é¢
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, width, height);

    // ç•«é¢éœ‡å‹•
    if(state.shake > 0) {
        ctx.save();
        const sx = (Math.random()-0.5) * state.shake;
        const sy = (Math.random()-0.5) * state.shake;
        ctx.translate(sx, sy);
        state.shake *= 0.9;
        if(state.shake < 0.5) state.shake = 0;
    }

    // ç¹ªè£½èƒŒæ™¯ç¶²æ ¼ (é€è¦–æ„Ÿ)
    drawBackground();

    if (state.isPlaying) {
        // æ›´æ–°ç±ƒæ¡†ç§»å‹• (é›£åº¦éš¨åˆ†æ•¸å¢åŠ )
        let speed = 1 + state.score * 0.05;
        state.hoop.x += state.hoop.dir * speed;
        if (state.hoop.x > width/2 - 50 || state.hoop.x < -width/2 + 50) {
            state.hoop.dir *= -1;
        }

        state.ball.update();
    }

    // ç¹ªè£½é †åºï¼šç±ƒæ¿ -> ç±ƒç¶²(å¾Œ) -> çƒ(è‹¥åœ¨ç±ƒæ¡†å¾Œ) -> ç±ƒæ¡† -> çƒ(è‹¥åœ¨ç±ƒæ¡†å‰) -> ç±ƒç¶²(å‰) -> ç²’å­ -> UI
    
    drawBackboard();
    drawNet(false); // å¾ŒåŠéƒ¨ç¶²å­

    const ballBehind = state.ball.z > state.hoop.z;
    if (ballBehind) state.ball.draw(ctx);

    drawRim();

    if (!ballBehind) state.ball.draw(ctx);
    
    drawNet(true); // å‰åŠéƒ¨ç¶²å­
    drawDragLine();
    
    // ç²’å­
    state.particles.forEach((p, i) => {
        p.update();
        p.draw(ctx);
        if(p.life <= 0) state.particles.splice(i, 1);
    });

    // æµ®å‹•æ–‡å­—
    floatTexts.forEach((ft, i) => {
        ft.y -= 1;
        ft.life -= 0.02;
        ctx.globalAlpha = ft.life;
        ctx.font = "bold 30px 'Black Ops One'";
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 3;
        ctx.strokeText(ft.text, ft.x, ft.y);
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1;
        if(ft.life <= 0) floatTexts.splice(i, 1);
    });

    if(state.shake > 0) ctx.restore();

    requestAnimationFrame(loop);
}

// --- ç¹ªåœ–è¼”åŠ© ---

function project(x, y, z) {
    const scale = CONSTANTS.PERSPECTIVE / (CONSTANTS.PERSPECTIVE + z);
    return {
        x: width/2 + (x - width/2) * scale,
        y: height/2 + (y - height/2) * scale,
        scale: scale
    };
}

function drawBackground() {
    // åœ°æ¿
    const p1 = project(0, CONSTANTS.FLOOR_Y, 0);
    const p2 = project(width, CONSTANTS.FLOOR_Y, 0);
    const p3 = project(width, CONSTANTS.FLOOR_Y, 1000);
    const p4 = project(0, CONSTANTS.FLOOR_Y, 1000);

    const grad = ctx.createLinearGradient(0, height/2, 0, height);
    grad.addColorStop(0, '#1e293b');
    grad.addColorStop(1, '#0f172a');
    ctx.fillStyle = grad;
    ctx.fillRect(0, p1.y, width, height - p1.y);

    // ç¶²æ ¼ç·š
    ctx.strokeStyle = 'rgba(6, 182, 212, 0.2)'; // Cyan-500 low opacity
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let z=0; z<1000; z+=100) {
        const l1 = project(-width, CONSTANTS.FLOOR_Y, z);
        const l2 = project(width*2, CONSTANTS.FLOOR_Y, z);
        ctx.moveTo(l1.x, l1.y); ctx.lineTo(l2.x, l2.y);
    }
    for(let x=-width; x<width*2; x+=100) {
        const l1 = project(x, CONSTANTS.FLOOR_Y, 0);
        const l2 = project(x, CONSTANTS.FLOOR_Y, 1000);
        ctx.moveTo(l1.x, l1.y); ctx.lineTo(l2.x, l2.y);
    }
    ctx.stroke();
}

function drawBackboard() {
    const p = project(state.hoop.x, state.hoop.y, state.hoop.z);
    const scale = p.scale;
    
    const w = 180 * scale;
    const h = 120 * scale;
    const x = p.x - w/2;
    const y = p.y - h - 20*scale;

    // ç±ƒæ¿æ”¯æ¶
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 10 * scale;
    ctx.beginPath();
    ctx.moveTo(p.x, y + h/2);
    ctx.lineTo(p.x, height); // å»¶ä¼¸åˆ°åœ°æ¿
    ctx.stroke();

    // ç±ƒæ¿ç»ç’ƒ
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2 * scale;
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#06b6d4'; // Cyan neon
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);
    ctx.shadowBlur = 0;

    // ç±ƒæ¿å…§æ¡†
    ctx.strokeStyle = '#ef4444'; // Red
    ctx.lineWidth = 3 * scale;
    ctx.strokeRect(x + w*0.35, y + h*0.6, w*0.3, h*0.3);
}

function drawRim() {
    const p = project(state.hoop.x, state.hoop.y, state.hoop.z);
    const scale = p.scale;
    const r = CONSTANTS.RIM_RADIUS * scale;

    ctx.beginPath();
    // ç•«ä¸€å€‹å£“æ‰çš„åœ“ç’°
    ctx.ellipse(p.x, p.y, r, r * 0.3, 0, 0, Math.PI * 2);
    ctx.strokeStyle = '#f97316'; // Orange-500
    ctx.lineWidth = 4 * scale;
    ctx.shadowBlur = 5;
    ctx.shadowColor = '#ea580c';
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function drawNet(isFront) {
    const p = project(state.hoop.x, state.hoop.y, state.hoop.z);
    const scale = p.scale;
    const r = CONSTANTS.RIM_RADIUS * scale;
    const netHeight = 40 * scale;
    const segments = 8;

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 1 * scale;
    ctx.beginPath();

    // ç°¡å–®çš„ç¶²å­ç¹ªè£½é‚è¼¯
    const startAngle = isFront ? 0 : Math.PI;
    const endAngle = isFront ? Math.PI : Math.PI * 2;

    for (let i = 0; i <= segments; i++) {
        const angle = startAngle + (i / segments) * Math.PI;
        const x = p.x + Math.cos(angle) * r;
        const y = p.y + Math.sin(angle) * (r * 0.3);
        
        // ç¶²å­æ”¶ç¸®æ•ˆæœ
        const x2 = p.x + Math.cos(angle) * (r * 0.6);
        const y2 = p.y + netHeight + Math.sin(angle) * (r * 0.2);

        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        
        // æ©«ç·š
        if(i < segments) {
             const angleNext = startAngle + ((i+1) / segments) * Math.PI;
             const xNext = p.x + Math.cos(angleNext) * r;
             const yNext = p.y + Math.sin(angleNext) * (r * 0.3);
             const x2Next = p.x + Math.cos(angleNext) * (r * 0.6);
             const y2Next = p.y + netHeight + Math.sin(angleNext) * (r * 0.2);
             
             // ä¸­é–“äº¤å‰
             ctx.moveTo(x, y); ctx.lineTo(x2Next, y2Next);
             ctx.moveTo(xNext, yNext); ctx.lineTo(x2, y2);
        }
    }
    ctx.stroke();
}

function drawDragLine() {
    if(!state.drag.active || state.ball.isFlying) return;

    const startX = state.drag.startX;
    const startY = state.drag.startY;
    const currX = state.drag.currX;
    const currY = state.drag.currY;

    // ç¹ªè£½æ‹‰ç·š (Slingshot effect)
    ctx.beginPath();
    ctx.moveTo(state.ball.x, state.ball.y);
    ctx.lineTo(currX, currY);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 3;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);

    // ç¹ªè£½é æ¸¬è»Œè·¡ (ç°¡å–®æ‹‹ç‰©ç·š)
    // åå‘å‘é‡
    let dx = startX - currX;
    let dy = startY - currY;
    const power = 0.18;
    let simX = state.ball.x;
    let simY = state.ball.y;
    let simVx = dx * 0.2;
    let simVy = -Math.min(Math.max(dy * 0.4, 15), 40);
    
    ctx.beginPath();
    ctx.moveTo(simX, simY);
    for(let i=0; i<10; i++) {
        simVy += CONSTANTS.GRAVITY * 3; // é æ¸¬åŠ é€Ÿé‡åŠ›æ¨¡æ“¬
        simX += simVx;
        simY += simVy;
        ctx.lineTo(simX, simY);
    }
    ctx.strokeStyle = 'rgba(6, 182, 212, 0.6)'; // Cyan guide
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // æ‹‰å‹•åœ“é»
    ctx.beginPath();
    ctx.arc(currX, currY, 15, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.fill();
}

// å•Ÿå‹•
window.onload = init;

</script>
</body>
</html>
