<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D視角籃球遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* 防止觸控時的滾動等預設行為 */
        }
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 100%); /* 天空背景 */
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4 antialiased overflow-hidden">

    <div class="relative w-full max-w-lg aspect-[3/4] rounded-2xl shadow-2xl overflow-hidden border-4 border-gray-700">
        <canvas id="gameCanvas"></canvas>

        <!-- 遊戲 UI -->
        <div id="gameUI" class="absolute inset-0 pointer-events-none hidden">
            <div class="p-4 flex justify-between items-center text-white">
                <div class="bg-black/60 backdrop-blur-sm rounded-lg px-4 py-2">
                    <span class="font-bold">得分: </span>
                    <span id="score" class="text-2xl font-black text-green-400">0</span>
                </div>
                <div class="bg-black/60 backdrop-blur-sm rounded-lg px-4 py-2">
                    <span class="font-bold">時間: </span>
                    <span id="time" class="text-2xl font-black text-yellow-400">45</span>
                </div>
            </div>
        </div>

        <!-- 開始畫面 -->
        <div id="startScreen" class="absolute inset-0 bg-black/70 backdrop-blur-md flex flex-col justify-center items-center text-center p-8 z-10">
            <div class="bg-white/10 p-8 rounded-2xl">
                <h1 class="text-5xl font-black text-white mb-3 drop-shadow-lg">街頭籃球王</h1>
                <p class="text-lg text-gray-200 mb-8">向上滑動來投籃！</p>
                <button id="startButton" class="bg-indigo-600 text-white font-bold text-2xl py-3 px-10 rounded-full hover:bg-indigo-500 active:scale-95 transform transition-all duration-200 shadow-lg">
                    挑戰開始
                </button>
            </div>
        </div>

        <!-- 遊戲結束畫面 -->
        <div id="gameOverScreen" class="absolute inset-0 bg-black/70 backdrop-blur-md flex flex-col justify-center items-center text-center p-8 z-10 hidden">
             <div class="bg-white/10 p-8 rounded-2xl">
                <h2 class="text-5xl font-black text-white mb-2 drop-shadow-lg">時間到！</h2>
                <p class="text-xl text-gray-200">最終得分</p>
                <p id="finalScore" class="text-8xl font-black text-yellow-300 my-4 drop-shadow-xl">0</p>
                <button id="restartButton" class="bg-teal-500 text-white font-bold text-2xl py-3 px-10 rounded-full hover:bg-teal-400 active:scale-95 transform transition-all duration-200 shadow-lg">
                    再戰一場
                </button>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- DOM 元素 ---
    const uiElements = {
        startScreen: document.getElementById('startScreen'),
        gameOverScreen: document.getElementById('gameOverScreen'),
        gameUI: document.getElementById('gameUI'),
        score: document.getElementById('score'),
        time: document.getElementById('time'),
        finalScore: document.getElementById('finalScore'),
        startButton: document.getElementById('startButton'),
        restartButton: document.getElementById('restartButton'),
    };

    // --- 遊戲常數 ---
    const GAME_DURATION = 45;
    const GRAVITY = 0.1;
    const PERSPECTIVE = 0.8; // 深度感強度
    const FLOOR_LEVEL = 0.8; // 地板在畫面的 Y 軸百分比

    // --- 遊戲狀態 ---
    let gameState = {
        score: 0,
        time: GAME_DURATION,
        active: false,
        countdownInterval: null,
    };

    let ball, hoop, dragStartPoint, dragEndPoint;
    let scoreAnimations = [];

    // --- 物件類別 ---
    class Ball {
        constructor(x, y, z, radius) {
            this.x = x; this.y = y; this.z = z;
            this.radius = radius;
            this.vx = 0; this.vy = 0; this.vz = 0;
            this.isShooting = false;
        }

        draw() {
            const scale = 1 / (1 + this.z * PERSPECTIVE);
            const screenX = this.x;
            const screenY = canvas.height * FLOOR_LEVEL - (canvas.height * 0.5 - this.y) * scale;
            const screenRadius = this.radius * scale;

            if (screenY + screenRadius < 0) return; // 在畫面外就不繪製

            // 陰影
            const shadowY = canvas.height * FLOOR_LEVEL;
            const shadowRadius = screenRadius * 0.7;
            const shadowAlpha = Math.max(0, 0.5 - this.y / (canvas.height * 2));
            ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
            ctx.beginPath();
            ctx.ellipse(screenX, shadowY, shadowRadius, shadowRadius / 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // 球體
            const gradient = ctx.createRadialGradient(
                screenX - screenRadius/2, screenY - screenRadius/2, 1,
                screenX, screenY, screenRadius
            );
            gradient.addColorStop(0, '#ffb861');
            gradient.addColorStop(0.8, '#f57c00');
            gradient.addColorStop(1, '#bf360c');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            if (this.isShooting) {
                this.vy -= GRAVITY;
                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;

                if (this.z < 0) { // 球回到玩家手上
                    this.isShooting = false;
                    resetBall();
                }
            }
        }
    }

    class Hoop {
        constructor() {
            this.x = canvas.width / 2;
            this.y = 150;
            this.z = 10;
            this.width = 100;
            this.rimRadius = 12; // 籃框碰撞半徑
            this.speed = 1.5;
            this.direction = 1;
        }

        draw() {
            const scale = 1 / (1 + this.z * PERSPECTIVE);
            const screenX = this.x;
            const screenY = canvas.height * FLOOR_LEVEL - (canvas.height * 0.5 - this.y) * scale;
            const screenWidth = this.width * scale;

            // 籃板
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2 * scale;
            ctx.fillRect(screenX - screenWidth/2, screenY - screenWidth*0.4, screenWidth, screenWidth*0.8);
            ctx.strokeRect(screenX - screenWidth/2, screenY - screenWidth*0.4, screenWidth, screenWidth*0.8);
            
            // 籃框
            ctx.strokeStyle = '#FF4500';
            ctx.lineWidth = 5 * scale;
            ctx.beginPath();
            ctx.ellipse(screenX, screenY + screenWidth*0.45, screenWidth/2.2, screenWidth/8, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        update() {
            this.x += this.speed * this.direction;
            if (this.x > canvas.width - this.width/2 || this.x < this.width/2) {
                this.direction *= -1;
            }
        }
    }

    // --- 核心函數 ---
    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        uiElements.startButton.onclick = startGame;
        uiElements.restartButton.onclick = startGame;

        canvas.addEventListener('mousedown', onDragStart);
        canvas.addEventListener('mousemove', onDragMove);
        window.addEventListener('mouseup', onDragEnd);

        canvas.addEventListener('touchstart', onDragStart, { passive: false });
        canvas.addEventListener('touchmove', onDragMove, { passive: false });
        window.addEventListener('touchend', onDragEnd);

        gameLoop();
    }

    function resizeCanvas() {
        canvas.width = canvas.parentElement.offsetWidth;
        canvas.height = canvas.parentElement.offsetHeight;
        hoop = new Hoop();
        resetBall();
    }
    
    function resetBall() {
        ball = new Ball(canvas.width / 2, -100, 0, 30);
    }
    
    function startGame() {
        gameState.score = 0;
        gameState.time = GAME_DURATION;
        gameState.active = true;
        
        uiElements.startScreen.classList.add('hidden');
        uiElements.gameOverScreen.classList.add('hidden');
        uiElements.gameUI.classList.remove('hidden');

        uiElements.score.textContent = gameState.score;
        uiElements.time.textContent = gameState.time;
        
        resetBall();

        if (gameState.countdownInterval) clearInterval(gameState.countdownInterval);
        gameState.countdownInterval = setInterval(() => {
            gameState.time--;
            uiElements.time.textContent = gameState.time;
            if (gameState.time <= 0) {
                endGame();
            }
        }, 1000);
    }

    function endGame() {
        gameState.active = false;
        clearInterval(gameState.countdownInterval);
        uiElements.finalScore.textContent = gameState.score;
        uiElements.gameOverScreen.classList.remove('hidden');
        uiElements.gameUI.classList.add('hidden');
    }

    function checkCollision() {
        if (!ball.isShooting) return;

        const dz = Math.abs(ball.z - hoop.z);
        if (dz < 1 && ball.vy < 0) { // 球在籃框附近且正在下落
            const dx = Math.abs(ball.x - hoop.x);
            const dy = Math.abs(ball.y - (hoop.y + 20)); // +20微調籃框Y
            
            if (dx < hoop.rimRadius && dy < hoop.rimRadius) {
                gameState.score++;
                uiElements.score.textContent = gameState.score;
                ball.isShooting = false;
                
                // 得分動畫
                scoreAnimations.push({
                    text: "Swish!",
                    x: hoop.x, y: hoop.y,
                    alpha: 1, size: 20
                });

                setTimeout(resetBall, 200);
            }
        }
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        if (!gameState.active) return;
        ball.update();
        hoop.update();
        checkCollision();

        // 更新得分動畫
        scoreAnimations.forEach((anim, i) => {
            anim.y += 1;
            anim.alpha -= 0.02;
            anim.size += 0.5;
            if (anim.alpha <= 0) scoreAnimations.splice(i, 1);
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 地板
        ctx.fillStyle = '#6B8E23';
        ctx.fillRect(0, canvas.height * FLOOR_LEVEL, canvas.width, canvas.height * (1-FLOOR_LEVEL));
        
        hoop.draw();
        ball.draw();
        drawTrajectory();

        // 繪製得分動畫
        scoreAnimations.forEach(anim => {
            const scale = 1 / (1 + hoop.z * PERSPECTIVE);
            ctx.font = `bold ${anim.size * scale}px "Noto Sans TC"`;
            ctx.fillStyle = `rgba(255, 255, 255, ${anim.alpha})`;
            ctx.textAlign = 'center';
            ctx.fillText(anim.text, anim.x, canvas.height * FLOOR_LEVEL - (canvas.height * 0.5 - anim.y) * scale);
        });
    }

    function drawTrajectory() {
        if (!dragStartPoint || !dragEndPoint || ball.isShooting) return;
        ctx.beginPath();
        ctx.moveTo(dragStartPoint.x, dragStartPoint.y);
        ctx.lineTo(dragEndPoint.x, dragEndPoint.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // --- 事件處理 ---
    function getEventCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    function onDragStart(e) {
        if (!gameState.active || ball.isShooting) return;
        if(e.cancelable) e.preventDefault();
        dragStartPoint = getEventCoords(e);
        dragEndPoint = dragStartPoint;
    }

    function onDragMove(e) {
        if (!dragStartPoint || ball.isShooting) return;
        if(e.cancelable) e.preventDefault();
        dragEndPoint = getEventCoords(e);
    }

    function onDragEnd() {
        if (!dragStartPoint || !dragEndPoint || ball.isShooting) return;
        
        const dy = dragStartPoint.y - dragEndPoint.y;
        const dx = dragStartPoint.x - dragEndPoint.x;
        
        if (dy > 20) { // 必須有足夠的向上滑動
            ball.isShooting = true;
            ball.vx = -dx * 0.1;
            ball.vy = dy * 0.2;
            ball.vz = dy * 0.08;
        }

        dragStartPoint = null;
        dragEndPoint = null;
    }

    init();
</script>
</body>
</html>
